
# ===============================================
# START: Enums

enum RequestMode {
  test,
  match,
  replace
}

#  END:  Enums
# ===============================================
# START: Interfaces

interface IapiResponse {
  """Whether or not the request was OK or not"""
  ok: true,
  """Code for response type success/error type"""
  code: number,
  """List of results for test of each supplied regex"""
  content: [ResponseBody],
  """Human readable description of success/error type"""
  message: string

}

#  END:  Interfaces
# ===============================================
# START: Types

type Delimiters {
  open: String!,
  close: String!,
}

type Regex {
  id: ID!,
  """Regular expression pattern (without delimiters or modifiers"""
  pattern: String!,
  """Regular expression modifiers"""
  modifiers: String!,
  """Regular expression"""
  delimiters: Delimiters
}

type regexMatchReplace implements Regex {
  id: ID!
  pattern: String!,
  modifiers: String!,
  delimiters: Delimiters,
  """Replacement string/pattern"""
  replace: String!,
  """Whether or not to transform white space escape sequences into their normal white space character equivalents"""
  TransformWhiteSpace: Boolean!
}

type MatchConfig {
  """The maximum number of characters a captured sub-pattern can be before it is truncated"""
  maxSubMatchLen: number,
  """The maximum number of characters the whole matched pattern can be before it is truncated"""
  maxWholeMatchLen: number
}

type Samples {
  """List of sample strings regexes are to be applyed to"""
  sampleStrs: [string],
  """If splitChar is not empty string, split the sample string on that chatacter"""
  splitChar: string,
  """Trim whitec space from begining and end of samples before processing regexes"""
  trimBefore: boolean,
  """Trim whitec space from end of samples after processing regexes"""
  trimAfter: boolean
  trimBefore: boolean,
  trimAfter: boolean
  
}

# -----------------------------------------------
# START: Request types



type APItestRequest {
  type: RequestMode!,
  """List of regexes to be tested for validity"""
  regexes: [Regex]!
}

type APIreplaceRequest implements APItestRequest {
  type: RequestMode!,
  """List of regexes to apply to sample strings"""
  regexes: [regexMatchReplace]!,
  """List of sample strings to which regexes are to be applied"""
  sampleStrings: [String]!
}

type APImatchRequest implements APIreplaceRequest {
  type: RequestMode!,
  regexes: [regexMatchReplace]!,
  sampleStrings: [String]!
  """Whether or not to apply find/replace sequentially on strings or to apply find/replace to fresh version of original string"""
  chainRegexes: Boolean!,
  """Control how much text is returned for each match"""
  matchConfig: MatchConfig
}



#  END:  Request types
# -----------------------------------------------
# START: Response types



type APIinvalidRequestResponse implements IapiResponse {
  """Whether or not the request was OK or not"""
  ok: false,
  """Code for response type success/error type"""
  code: number,
  """Error message"""
  content: String!,
  """Human readable description of success/error type"""
  message: string
}

type APItestResponse implements IapiResponse {
  """Whether or not the request was OK or not"""
  ok: true,
  """Code for response type success/error type"""
  code: number,
  """List of results for test of each supplied regex"""
  content: [TestResponse],
  """Human readable description of success/error type"""
  message: string
}

type APImatchResponse implements IapiResponse {
  ok: true,
  code: number,
  content: [MatchResponse],
  message: string,
  """Whether or not contents objects include timings for processing of regexes"""
  hasTiming: Boolean
}

type APIreplaceResponse implements IapiResponse {
  ok: true,
  code: number,
  content: [ReplaceResponse],
  message: string,
  """Whether or not contents objects include timings for processing of regexes"""
  hasTiming: Boolean
}

# - - - - - - - - - - - - - - - - - - - - - - - -
# START: Response sub-types

type matchParts {
  key: String | Number,
  value: String
}

type ResponseCapturedMatches {
  wholeMatch: string,
  parts: [matchParts],
}

type RegexError {
  """If there's an issue within the regex pattern. badCharacter is the character at which the issue starts"""
  badCharacter: string,
  """Message delimiters errors"""
  delimiterError: String,
  """Message for modifiers errors"""
  modifierError: String,
  """If there's an issue within the regex pattern. offset is the index of the character at which the issue starts"""
  offset: number,
  """Message for pattern errors"""
  patternError: String,
  """Raw error message generated by regex engine"""
  rawMessage: string,
}

type ResponseRegex {
  id: ID!,
  """Whether or not the regex (as a whole) was valid"""
  isValid: Boolean!,
  """Details about errors in regex"""
  error: RegexError
}


type TestResponse {
  regex: ResponseRegex!
}

type MatchResponse implements TestResponse {
  regex: ResponseRegex!,
  """List of matches for a given regex & supplied strings"""
  matches: [ResponseCapturedMatches]!,
  """Number of miliseconds the matching took the engine to execute (if available for that engine/platform)"""
  duration: Number
}

type ReplaceResponse {
  """List of supplied sample strings, transformed by supplied regexes"""
  transformedSamples: [TransformedSample]!
}

type TransformedSample {
  sample: String!,
  duration: Number
}

#  END:  Response sub-types
# - - - - - - - - - - - - - - - - - - - - - - - -


#  END:  Response types
# -----------------------------------------------

#  END:  Types
# ===============================================
# START: Unions

union ResponseBody = RegexError | TestResponse | MatchResponse | ReplaceResponse

#  END:  Unions
# ===============================================
# START: Scalars

#  END:  Scalars
# ===============================================
